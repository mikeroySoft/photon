<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>– Managing the Network Configuration</title><link>/docs/administration-guide/managing-network-configuration/</link><description>Recent content in Managing the Network Configuration on</description><generator>Hugo -- gohugo.io</generator><atom:link href="/docs/administration-guide/managing-network-configuration/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Commands to Manage Network Service</title><link>/docs/administration-guide/managing-network-configuration/network-management-commands/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/administration-guide/managing-network-configuration/network-management-commands/</guid><description>
&lt;p>You manage the network service by using systemd commands, such as &lt;code>systemd-networkd&lt;/code>, &lt;code>systemd-resolvd&lt;/code>, and &lt;code>networkctl&lt;/code>.&lt;/p>
&lt;p>To check the status of the network service, run the following command:&lt;/p>
&lt;pre>&lt;code>systemctl status systemd-networkd
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Output&lt;/strong>&lt;/p>
&lt;pre>&lt;code>* systemd-networkd.service - Network Service
Loaded: loaded (/usr/lib/systemd/system/systemd-networkd.service; enabled; vendor preset: enabled)
Active: active (running) since Fri 2016-04-29 15:08:51 UTC; 6 days ago
Docs: man:systemd-networkd.service(8)
Main PID: 291 (systemd-network)
Status: &amp;quot;Processing requests...&amp;quot;
CGroup: /system.slice/systemd-networkd.service
`-291 /lib/systemd/systemd-networkd
&lt;/code>&lt;/pre>
&lt;p>Because Photon OS relies on systemd to manage services, you must use the &lt;code>systemd&lt;/code> suite of commands and not the deprecated &lt;code>init.d&lt;/code> commands or other deprecated commands to manage networking.&lt;/p></description></item><item><title>Docs: Using the Network Configuration Manager</title><link>/docs/administration-guide/managing-network-configuration/using-the-network-configuration-manager/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/administration-guide/managing-network-configuration/using-the-network-configuration-manager/</guid><description>
&lt;p>The network-config-manager &lt;code>nmctl&lt;/code> allows to configure and introspect the state of the network links as seen by s&lt;code>ystemd-networkd&lt;/code>. &lt;code>nmctl&lt;/code> can be used to query and configure links for Address, Routes, Gateways and also hostname, DNS, NTP or Domain. &lt;code>nmctl&lt;/code> uses &lt;code>sd-bus&lt;/code>, libudev APIs to interact with &lt;code>systemd&lt;/code>, &lt;code>systemd-networkd&lt;/code>, &lt;code>systemd-resolved&lt;/code>, &lt;code>systemd-hostnamed&lt;/code>, and &lt;code>systemd-timesyncd&lt;/code> via dbus. &lt;code>nmctl&lt;/code> uses networkd verbs to explain output. &lt;code>nmctl&lt;/code> can generate configurations for required network links from YAML description. It also understands kernel command line specified in dracut network configuration format and can generate &lt;code>systemd-networkd&lt;/code> configuration while the system boots and will persist between reboots.&lt;/p>
&lt;p>Note: See &lt;code>systemd.network&lt;/code> for more information.&lt;/p>
&lt;p>&lt;code>nmctl&lt;/code> is used to configure:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Static IPv4 and IPv6 Address, Routes, Gateway&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DHCP type (IPv4/IPv6), DHCP4 Client Identifier, UseMTU/UseDNS/UseDomains/UseNTP/UseRoutes.
LLDP, Link Local Addressing, IPv4LLRoute, LLMNR&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DNS, Domains and NTP&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Link MAC, MTU&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Create netdevs, vlan, vxlan, bridge, bond, veth, macvlan/macvtap, ipvlap/ipvtap, veth, tunnels(ipip, sit, gre, sit, vti), wireguard&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Hostname&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Add delete and view nftables table, chains and rules.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>You can use &lt;code>nmctl&lt;/code> to generate network configurations from the following:&lt;/p>
&lt;ul>
&lt;li>YAML file: &lt;code>nmctl&lt;/code> can generate configurations for required network links from YAML description. Configuration written to disk under &lt;code>/etc/systemd/network&lt;/code> will persist between reboots. When &lt;code>netmgr-yaml-generator.service&lt;/code> is enabled it reads YAML files from &lt;code>/etc/network-config-manager/yaml&lt;/code> and generates &lt;code>systemd-networkd&lt;/code> configuration files.&lt;/li>
&lt;/ul>
&lt;p>&lt;code>nmctl&lt;/code> uses similar format as defined by different YAML format.&lt;/p>
&lt;p>&lt;code>nmctl&lt;/code> can generate WPA Supplicant configuration from YAML file. When a YAML file with wifi configuration is found, it generates a configuration file found in &lt;code>/etc/network-config-manager/wpa_supplicant_photon_os.conf&lt;/code> which is understood by &lt;code>wpa_supplicant&lt;/code>.&lt;/p>
&lt;ul>
&lt;li>Dracut kernel command line network configuration: nmctl understands kernel command line specified in dracut&amp;rsquo;s network configuration format and can generate systemd-networkd&amp;rsquo;s configuration while the system boots and will persist between reboots.&lt;/li>
&lt;/ul>
&lt;p>Network
ip={dhcp|on|any|dhcp6|auto6}
dhcp|on|any: get ip from dhcp server from all links. If root=dhcp, loop
sequentially through all links (eth0, eth1, &amp;hellip;) and use the first with a valid
DHCP root-path.&lt;/p>
&lt;pre>&lt;code> auto6: IPv6 autoconfiguration
dhcp6: IPv6 DHCP
ip=&amp;lt;link&amp;gt;:{dhcp|on|any|dhcp6|auto6}
dhcp|on|any|dhcp6: get ip from dhcp server on a specific link
auto6: do IPv6 autoconfiguration
This parameter can be specified multiple times.
ip=&amp;lt;client-IP&amp;gt;:[ &amp;lt;server-id&amp;gt;]:&amp;lt;gateway-IP&amp;gt;:&amp;lt;netmask&amp;gt;:&amp;lt;client_hostname&amp;gt;:&amp;lt;link&amp;gt;:{none|off}
explicit network configuration.
ifname=&amp;lt;link&amp;gt;:&amp;lt;MAC&amp;gt;
Assign network device name &amp;lt;link&amp;gt; (ie eth0) to the NIC with MAC &amp;lt;MAC&amp;gt;. Note
letters in the MAC-address must be lowercase! Note: If you use this option you must
specify an ifname= argument for all links used in ip= or fcoe= arguments. This
parameter can be specified multiple times.
nameserver=&amp;lt;IP&amp;gt;[nameserver=&amp;lt;IP&amp;gt; ...]
specify nameserver(s) to use
cat /proc/cmdline
BOOT_IMAGE=/boot/vmlinuz-4.19.52-2.ph3-esx root=PARTUUID=ebf01b6d-7e9c-4345-93f4-122f44eb2726
init=/lib/systemd/systemd rcupdate.rcu_expedited=1 rw systemd.show_status=0 quiet noreplace-smp
cpu_init_udelay=0 net.ifnames=0 plymouth.enable=0 systemd.legacy_systemd_cgroup_controller=yes
ip=dhcp
&lt;/code>&lt;/pre>
&lt;p>&lt;code>network-config-manager-generator.service&lt;/code> is a oneshot type systemd service unit which runs while the system boots. It parses the kernel command line and generates networkd config in &lt;code>/etc/systemd/network&lt;/code>.&lt;/p>
&lt;pre>&lt;code>systemctl enable network-config-manager-generator.service
&lt;/code>&lt;/pre>
&lt;p>It creates symlink &lt;code>/etc/systemd/system/network.target.wants/network-config-manager-generator.service → /usr/lib/systemd/system/network-config-manager-generator.service&lt;/code>.&lt;/p>
&lt;p>For more information, see:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>CLI&lt;/strong> - see the &lt;code>-net&lt;/code> commands in the &lt;a href="../../../command-line-reference/commnad-line-interfaces/photon-management-daemon-cli/">Photon Management Daemon Command-line Interface (pmd-cli)&lt;/a>&lt;/li>
&lt;li>&lt;strong>C APIs&lt;/strong> - &lt;a href="../netmgr.c/">Network Configuration Manager - C API&lt;/a>&lt;/li>
&lt;li>&lt;strong>Python APIs&lt;/strong> - &lt;a href="../netmgr.python/">Network Configuration Manager - Python API&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: Use `ip` and `ss` Commands</title><link>/docs/administration-guide/managing-network-configuration/use-ip-and-ss-commands/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/administration-guide/managing-network-configuration/use-ip-and-ss-commands/</guid><description>
&lt;p>Use the &lt;code>ip&lt;/code> and &lt;code>ss&lt;/code> commands to view a list of network interfaces and information for IP addresses.&lt;/p>
&lt;p>Although the &lt;code>ifconfig&lt;/code> command and the &lt;code>netstat&lt;/code> command work on Photon OS, VMware recommends that you use the &lt;code>ip&lt;/code> or &lt;code>ss&lt;/code> commands. The &lt;code>ipconfig&lt;/code> and &lt;code>netstat&lt;/code> commands are deprecated.&lt;/p>
&lt;p>For example, to display a list of network interfaces, run the &lt;code>ss&lt;/code> command instead of &lt;code>netstat&lt;/code>. To display information for IP addresses, run the &lt;code>ip addr&lt;/code> command instead of &lt;code>ifconfig -a&lt;/code>.&lt;/p>
&lt;p>Examples are as follows:&lt;/p>
&lt;pre>&lt;code>USE THIS IPROUTE COMMAND INSTEAD OF THIS NET-TOOL COMMAND
ip addr ifconfig -a
ss netstat
ip route route
ip maddr netstat -g
ip link set eth0 up ifconfig eth0 up
ip -s neigh arp -v
ip link set eth0 mtu 9000 ifconfig eth0 mtu 9000
&lt;/code>&lt;/pre>
&lt;p>Using the &lt;code>ip route&lt;/code> version of a command instead of the net-tools version often provides more complete and accurate information on Photon OS. Examples are as follows:&lt;/p>
&lt;pre>&lt;code>ip neigh
198.51.100.2 dev eth0 lladdr 00:50:56:e2:02:0f STALE
198.51.100.254 dev eth0 lladdr 00:50:56:e7:13:d9 STALE
198.51.100.1 dev eth0 lladdr 00:50:56:c0:00:08 DELAY
arp -a
? (198.51.100.2) at 00:50:56:e2:02:0f [ether] on eth0
? (198.51.100.254) at 00:50:56:e7:13:d9 [ether] on eth0
? (198.51.100.1) at 00:50:56:c0:00:08 [ether] on eth0
&lt;/code>&lt;/pre></description></item><item><title>Docs: Configuring Network Interfaces</title><link>/docs/administration-guide/managing-network-configuration/configuring-network-interfaces/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/administration-guide/managing-network-configuration/configuring-network-interfaces/</guid><description>
&lt;p>Network configuration files for systemd-networkd reside in &lt;code>/etc/systemd/network&lt;/code> and &lt;code>/usr/lib/systemd/network&lt;/code>. Example:&lt;/p>
&lt;pre>&lt;code>root@photon-rc [ ~ ]# ls /etc/systemd/network/
99-dhcp-en.network
&lt;/code>&lt;/pre>
&lt;p>By default, when Photon OS starts, it creates a DHCP network configuration file, or rule, which appears in /etc/systemd/network, the highest priority directory for network configuration files with the lowest priority filename:&lt;/p>
&lt;pre>&lt;code>cat /etc/systemd/network/99-dhcp-en.network
[Match]
Name=e*
[Network]
DHCP=yes
&lt;/code>&lt;/pre>
&lt;p>Network configuration files can also appear in the system network directory, &lt;code>/usr/lib/systemd/network&lt;/code>, as the results of the following search illustrate:&lt;/p>
&lt;pre>&lt;code>root@photon-rc [ ~ ]# updatedb
root@photon-rc [ ~ ]# locate systemd/network
/etc/systemd/network
/etc/systemd/network/99-dhcp-en.network
/usr/lib/systemd/network
/usr/lib/systemd/network/80-container-host0.network
/usr/lib/systemd/network/80-container-ve.network
/usr/lib/systemd/network/99-default.link
root@photon-rc [ ~ ]#
&lt;/code>&lt;/pre>
&lt;p>In the above search, the &lt;code>/usr/lib/systemd/network&lt;/code> directory contains several network configuration files. Photon OS applies the configuration files in &lt;a href="https://en.wikipedia.org/wiki/Lexicographical_order">lexicographical order&lt;/a> specified by the file names without regard for the network configuration directory in which the file resides unless the file name is the same. Photon OS processes files with identical names by giving precedence to files in the &lt;code>/etc&lt;/code> directory over the other directory. Thus, the settings in &lt;code>/etc/systemd/network&lt;/code> override those in &lt;code>/usr/lib/systemd/network&lt;/code>. Once Photon OS matches an interface in a file, Photon OS ignores the interface if it appears in files processed later in the lexicographical order.&lt;/p>
&lt;p>Each .network file contains a matching rule and a configuration that Photon OS applies when a device matches the rule. Set the matching rule and the configuration as sections containing vertical sets of key-value pairs according to the information in &lt;a href="https://www.freedesktop.org/software/systemd/man/systemd.network.html">systemd network configuration&lt;/a>.&lt;/p>
&lt;p>To configure Photon OS to handle a networking use case, such as setting a static IP address or adding a name server, create a configuration file with a &lt;code>.network&lt;/code> extension and place it in the &lt;code>/etc/systemd/network directory&lt;/code>.&lt;/p>
&lt;p>After you create a network configuration file with a &lt;code>.network&lt;/code> extension, you must run the &lt;code>chmod&lt;/code> command to set the new file&amp;rsquo;s mode bits to &lt;code>644&lt;/code>. Example:&lt;/p>
&lt;pre>&lt;code>chown systemd-network:systemd-network 10-static-en.network
&lt;/code>&lt;/pre>
&lt;p>For Photon OS to apply the new configuration, you must restart the &lt;code>systemd-networkd&lt;/code> service by running the following command:&lt;/p>
&lt;pre>&lt;code>systemctl restart systemd-networkd
&lt;/code>&lt;/pre>
&lt;p>For information about network configuration files, their processing order, and their matching rules, sections, and keys, see &lt;a href="https://www.freedesktop.org/software/systemd/man/systemd.network.html">https://www.freedesktop.org/software/systemd/man/systemd.network.html&lt;/a>.&lt;/p>
&lt;p>For information about creating virtual network device files (&lt;code>.netdev&lt;/code>), see &lt;a href="https://www.freedesktop.org/software/systemd/man/systemd.netdev.html">https://www.freedesktop.org/software/systemd/man/systemd.netdev.html&lt;/a>.&lt;/p></description></item><item><title>Docs: Setting a Static IP Address</title><link>/docs/administration-guide/managing-network-configuration/setting-a-static-ip-address/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/administration-guide/managing-network-configuration/setting-a-static-ip-address/</guid><description>
&lt;p>Before you set a static IP address, obtain the name of your Ethernet link by running the following command:&lt;/p>
&lt;pre>&lt;code>networkctl
IDX LINK TYPE OPERATIONAL SETUP
1 lo loopback carrier unmanaged
2 eth0 ether routable configured
&lt;/code>&lt;/pre>
&lt;p>In the results of the command, you can see the name of an Ethernet link, &lt;code>eth0&lt;/code>.&lt;/p>
&lt;p>To create a network configuration file that systemd-networkd uses to establish a static IP address for the eth0 network interface, execute the following command as root:&lt;/p>
&lt;pre>&lt;code>cat &amp;gt; /etc/systemd/network/10-static-en.network &amp;lt;&amp;lt; &amp;quot;EOF&amp;quot;
[Match]
Name=eth0
[Network]
Address=198.51.0.2/24
Gateway=198.51.0.1
EOF
&lt;/code>&lt;/pre>
&lt;p>Change the new file&amp;rsquo;s mode bits by running the &lt;code>chmod&lt;/code> command:&lt;/p>
&lt;pre>&lt;code>chmod 644 10-static-en.network
&lt;/code>&lt;/pre>
&lt;p>Apply the configuration by running either the first or the second step:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;code>systemctl restart systemd-networkd &lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>networkctl reload&lt;/code>
&lt;code>networkctl reconfigure *interface_name/index_number*&lt;/code>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Note: The advantage of using reload and reconfigure is that the settings of other interfaces are not disturbed and only the settings of the specific interface are reloaded and reconfigured.&lt;/p>
&lt;p>For more information, see the man page for systemd-networkd: &lt;code>man systemd.network&lt;/code>&lt;/p></description></item><item><title>Docs: Turning Off DHCP</title><link>/docs/administration-guide/managing-network-configuration/turning-off-dhcp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/administration-guide/managing-network-configuration/turning-off-dhcp/</guid><description>
&lt;p>By default, when Photon OS first starts, it creates a DHCP network configuration file or rule, which appears in &lt;code>/etc/systemd/network&lt;/code>, the highest priority directory for network configuration files with the lowest priority filename:&lt;/p>
&lt;pre>&lt;code>cat /etc/systemd/network/99-dhcp-en.network
[Match]
Name=e*
[Network]
DHCP=yes
&lt;/code>&lt;/pre>
&lt;p>To turn off DHCP for all Ethernet interfaces, change the value of &lt;code>DHCP&lt;/code> from &lt;code>yes&lt;/code> to &lt;code>no&lt;/code>, save the changes, and then restart the &lt;code>systemd-networkd&lt;/code> service:&lt;/p>
&lt;pre>&lt;code>systemctl restart systemd-networkd
&lt;/code>&lt;/pre>
&lt;p>Or you can reload and reconfigure the settings:&lt;/p>
&lt;p>&lt;code>networkctl reload&lt;/code>
&lt;code>networkctl reconfigure &lt;/code> &lt;em>interface_name/index_number&lt;/em>``&lt;/p>
&lt;p>Note: The advantage of using reload and reconfigure is that the settings of other interfaces are not disturbed and only the settings of the specific interface are reloaded and reconfigured.&lt;/p>
&lt;p>If you create a configuration file with a higher priority filename (e.g. &lt;code>10-static-en.network&lt;/code>), it is not necessary but still recommended to turn off DHCP.&lt;/p>
&lt;p>You can also check the status of a specific interface:&lt;/p>
&lt;p>&lt;code>networkctl status&lt;/code> &lt;em>interface_name/index_number&lt;/em>&lt;/p>
&lt;p>(&lt;code>ens33 &lt;/code>is an example)&lt;/p>
&lt;pre>&lt;code>2: ens33
Link File: /usr/lib/systemd/network/99-default.link
Network File: /usr/lib/systemd/network/10-eth.network
Type: ether
State: routable (configured)
Alternative Names: enp2s1
Path: pci-0000:02:01.0
Driver: e1000
Vendor: Intel Corporation
Model: 82545EM Gigabit Ethernet Controller (Copper) (PRO/1000 MT Single Port Adapter)
HW Address: 00:0c:29:5f:d1:39 (VMware, Inc.)
MTU: 1500 (min: 46, max: 16110)
QDisc: fq_codel
IPv6 Address Generation Mode: eui64
Queue Length (Tx/Rx): 1/1
Auto negotiation: yes
Speed: 1Gbps
Duplex: full
Port: tp
Address: 172.16.85.225 (DHCP4 via 172.16.85.254)
fe80::20c:29ff:fe5f:d139
Gateway: 172.16.85.2 (VMware, Inc.)
DNS: 172.16.85.2
DHCP4 Client ID: IAID:0x2b9434c1/DUID
DHCP6 Client DUID: DUID-EN/Vendor:0000ab11d258482fc7eee6510000
Feb 26 10:19:44 fedora systemd-networkd[650]: ens33: Link UP
Feb 26 10:19:44 fedora systemd-networkd[650]: ens33: Gained carrier
Feb 26 10:19:45 fedora systemd-networkd[650]: ens33: DHCPv4 address 172.16.85.225/24 via 172.16.85.2
Feb 26 10:19:46 fedora systemd-networkd[650]: ens33: Gained IPv6LL
&lt;/code>&lt;/pre></description></item><item><title>Docs: Adding a DNS Server</title><link>/docs/administration-guide/managing-network-configuration/adding-a-dns-server/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/administration-guide/managing-network-configuration/adding-a-dns-server/</guid><description>
&lt;p>Photon OS uses &lt;code>systemd-resolved&lt;/code> to resolve domain names, IP addresses, and network names for local applications. The &lt;code>systemd-resolved&lt;/code> daemon automatically creates and maintains the &lt;code>/etc/resolv.conf&lt;/code> file, into which systemd-resolved places the IP address of the DNS server. You must not modify the &lt;code>/etc/resolv.conf&lt;/code> file.&lt;/p>
&lt;p>&lt;strong>Note&lt;/strong>: If you want to implement a local resolver like &lt;code>bind&lt;/code> instead of &lt;code>systemd-resolved&lt;/code>, stop the &lt;code>systemd-resolved&lt;/code> service and disable it.&lt;/p>
&lt;p>If you open the default &lt;code>/etc/resolv.conf&lt;/code> file after you deploy Photon OS, it looks like this:&lt;/p>
&lt;pre>&lt;code>root@photon-rc [ ~ ]# cat /etc/resolv.conf
# This file is managed by systemd-resolved(8). Do not edit.
#
# Third party programs must not access this file directly, but
# only through the symlink at /etc/resolv.conf. To manage
# resolv.conf(5) in a different way, replace the symlink by a
# static file or a different symlink.
nameserver 198.51.100.2
&lt;/code>&lt;/pre>
&lt;p>To add a DNS server, insert a DNS key into the Network section of the static network configuration file, for example, &lt;code>/etc/systemd/network/10-eth0-static.network&lt;/code> and set it to the IP address of your DNS server:&lt;/p>
&lt;pre>&lt;code>[Match]
Name=e*
[Network]
Address=198.51.0.2/24
Gateway=198.51.0.1
DNS=198.51.0.1
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Note&lt;/strong>: To apply the changes made to &lt;code>/etc/systemd/network/*.network&lt;/code> files, perform the following:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Restart &lt;code>systemd-networkd&lt;/code> and &lt;code>systemd-resolved&lt;/code> services by running the following commands:&lt;/p>
&lt;ul>
&lt;li>&lt;code>systemctl restart systemd-networkd&lt;/code>&lt;/li>
&lt;li>&lt;code>systemctl restart systemd-resolved&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Or you can reload and reconfigure the settings by running the following commands:
&lt;code>networkctl reload&lt;/code>
&lt;code>networkctl reconfigure *interface_name/index_number*&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Note: The advantage of using reload and reconfigure is that the settings of other interfaces are not disturbed and only the settings of the specific interface are reloaded and reconfigured.&lt;/p>
&lt;p>If your machine is working with DHCP, you can add a DNS server by modifying the &lt;code>/etc/systemd/resolved.conf--a&lt;/code> method.&lt;/p>
&lt;p>For more information, see &lt;a href="https://www.freedesktop.org/software/systemd/man/resolved.conf.html">https://www.freedesktop.org/software/systemd/man/resolved.conf.html&lt;/a>.&lt;/p>
&lt;p>You can optionally activate the local DNS stub resolver of systemd-resolved by adding &lt;code>dns&lt;/code> and &lt;code>resolve&lt;/code> to the &lt;code>/etc/nsswitch.conf&lt;/code> file. To do so, make a backup copy of the &lt;code>/etc/nsswitch.conf&lt;/code> file and then execute the following command as root:&lt;/p>
&lt;pre>&lt;code>sed -i 's/^hosts.*$/hosts: files resolve dns/' /etc/nsswitch.conf
&lt;/code>&lt;/pre>
&lt;p>For more information about the &lt;code>systemd-resolved&lt;/code> service, see &lt;a href="https://www.freedesktop.org/software/systemd/man/systemd-resolved.service.html">https://www.freedesktop.org/software/systemd/man/systemd-resolved.service.html&lt;/a>.&lt;/p></description></item><item><title>Docs: Setting Up Networking for Multiple NICs</title><link>/docs/administration-guide/managing-network-configuration/setting-up-networking-for-multiple-nics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/administration-guide/managing-network-configuration/setting-up-networking-for-multiple-nics/</guid><description>
&lt;p>If your machine contains multiple NICs, it is recommend that you create a &lt;code>.network&lt;/code> configuration file for each network interface. The following scenario demonstrates how to set one wired network interface to use a static IP address and another wired network interface to use a dynamic IP address obtained through DHCP.&lt;/p>
&lt;p>&lt;strong>Note&lt;/strong>: The following configurations are examples and you must change the IP addresses and other information to match your network and requirements.&lt;/p>
&lt;p>First, create the &lt;code>.network&lt;/code> file for the static Ethernet connection in &lt;code>/etc/systemd/network&lt;/code>. A best practice is to match the exact name of the network interface, which is &lt;code>eth0&lt;/code> in this example. This example file also includes a DNS server for the static IP address. As a result, the configuration sets the UseDNS key to false in the DHCP column so that Photon OS ignores the DHCP server for DNS for this interface.&lt;/p>
&lt;pre>&lt;code>cat &amp;gt; /etc/systemd/network/10-eth0-static-en.network &amp;lt;&amp;lt; &amp;quot;EOF&amp;quot;
[Match]
Name=eth0
[Network]
Address=10.137.20.11/19
Gateway=10.137.23.253
DNS=10.132.71.1
[DHCP]
UseDNS=false
EOF
&lt;/code>&lt;/pre>
&lt;p>Second, create the &lt;code>.network&lt;/code> file for the second network interface, which is &lt;code>eth1&lt;/code> in this example. This configuration file sets the eth1 interface to an IP address from DHCP and sets DHCP as the source for DNS lookups. Setting the DHCP key to &lt;code>yes&lt;/code> acquires an IP address for IPv4 and IPv6. To acquire an IP address for IPv4 only, set the DHCP key to &lt;code>ipv4&lt;/code>.&lt;/p>
&lt;pre>&lt;code>cat &amp;gt; /etc/systemd/network/50-eth1-dhcp-en.network &amp;lt;&amp;lt; &amp;quot;EOF&amp;quot;
[Match]
Name=eth1
[Network]
DHCP=yes
[DHCP]
UseDNS=true
EOF
&lt;/code>&lt;/pre>
&lt;h2 id="how-to-configure-two-gateways-for-two-different-nic-">How to configure two gateways for two different NIC ?&lt;/h2>
&lt;p>This is an IP routing policy feature of kernel and is supported by &lt;code>systemd-networkd&lt;/code>. You have to add two routes. One is for the subnet so that the IP address can find its gateway. The other route is for specifying the default gateway for that interface. Finally, we add policy route rules for that IP address that we want to use that table. This will not only ensure that the IP address you are trying to communicate with on that one interface can respond properly, but it will also ensure that you do not route information between subnets.&lt;/p>
&lt;pre>&lt;code>[Match]
Name=eth2
[Network]
Address=192.168.60.70/24
DHCP=no
[Route]
PreferredSource=192.168.60.70
Destination=192.168.60.0/24
Table=10
[Route]
Gateway=192.168.60.1
Table=10
[RoutingPolicyRule]
Table=10
To=192.168.60.70/24
[RoutingPolicyRule]
Table=10
From=192.168.60.70/24&lt;/code>&lt;/pre></description></item><item><title>Docs: Clearing the Machine ID of a Cloned Instance for DHCP</title><link>/docs/administration-guide/managing-network-configuration/clearing-the-machine-id-of-a-cloned-instance-for-dhcp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/administration-guide/managing-network-configuration/clearing-the-machine-id-of-a-cloned-instance-for-dhcp/</guid><description>
&lt;p>Photon OS uses the contents of &lt;code>/etc/machine-id&lt;/code> to determine the DHCP unique identifier (duid) that is used for DHCP requests. If you use a Photon OS instance as the base system for cloning, to create additional Photon OS instances, you must clear the &lt;code>machine-id&lt;/code> with this command:&lt;/p>
&lt;pre>&lt;code>echo -n &amp;gt; /etc/machine-id
&lt;/code>&lt;/pre>
&lt;p>When the value is cleared, &lt;code>machine-id&lt;/code> can be regenerated by calling &lt;code>systemd-machine-id-setup&lt;/code>.&lt;/p>
&lt;pre>&lt;code>systemd-machine-id-setup
&lt;/code>&lt;/pre>
&lt;p>This command initializes the machine ID stored in &lt;code>/etc/machine-id&lt;/code> during installation. For more information on this command, see &lt;a href="https://www.freedesktop.org/software/systemd/man/systemd-machine-id-setup.html">https://www.freedesktop.org/software/systemd/man/systemd-machine-id-setup.html&lt;/a>.&lt;/p></description></item><item><title>Docs: Using Predictable Network Interface Names</title><link>/docs/administration-guide/managing-network-configuration/using-predictable-network-interface-names/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/administration-guide/managing-network-configuration/using-predictable-network-interface-names/</guid><description>
&lt;p>When you run Photon OS on a virtual machine or a bare-metal machine, the Ethernet network interface name might shift from one device to another if you add or remove a card and reboot the machine. For example, a device named &lt;code>eth2&lt;/code> might become &lt;code>eth1&lt;/code> after you remove a NIC and restart the machine.&lt;/p>
&lt;p>You can prevent interface names from reordering by turning on &lt;a href="https://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames/">predictable network interface names&lt;/a>. The naming schemes that Photon OS uses can then assign fixed, predictable names to network interfaces even after you add or remove cards or other firmware and the restart the system.&lt;/p>
&lt;p>When you enable predictable network interface names, you can use one of the following options to assign persistent names to network interfaces:&lt;/p>
&lt;ul>
&lt;li>Apply the &lt;code>slot&lt;/code> name policy to set the name of networking devices in the &lt;code>ens&lt;/code> format with a statically assigned PCI slot number.&lt;/li>
&lt;li>Apply the &lt;code>mac&lt;/code> name policy to set the name of networking devices in the &lt;code>enx&lt;/code> format a unique MAC address.&lt;/li>
&lt;li>Apply the &lt;code>path&lt;/code> name policy to set the name of networking devices in the &lt;code>enpXsY&lt;/code> format derived from a device connector&amp;rsquo;s physical location.&lt;/li>
&lt;/ul>
&lt;p>Though Photon OS supports the &lt;code>onboard&lt;/code> name policy to set the name of networking devices from index numbers given by the firmware in the &lt;code>eno&lt;/code> format, the policy might result in nonpersistent names.&lt;/p>
&lt;p>The option to choose depends on your use case and your unique networking requirements. For example, when you clone virtual machines and require the MAC addresses to be different from one another but the interface name to be the same, consider using &lt;code>ens&lt;/code> to keep the slot the same after system reboots.&lt;/p>
&lt;p>Alternatively, if the cloning function supports &lt;code>enx&lt;/code>, you can use it to set a MAC address which persists after reboots.&lt;/p>
&lt;p>Perform the following steps to turn on predictable network interface names:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Make a backup copy of the following file in case you need to restore it later:&lt;/p>
&lt;pre>&lt;code>cp /boot/grub/grub.cfg /boot/grub/grub.cfg.original
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>To turn on predictable network interface names, edit &lt;code>/boot/grub/grub.cfg&lt;/code> to remove the following string:&lt;/p>
&lt;pre>&lt;code>net.ifnames=0Item
&lt;/code>&lt;/pre>&lt;p>The string appears near the bottom of the file in the &lt;code>menuentry&lt;/code> section:&lt;/p>
&lt;pre>&lt;code>menuentry &amp;quot;Photon&amp;quot; {
linux &amp;quot;/boot/&amp;quot;$photon_linux root=$rootpartition net.ifnames=0 $photon_cmdline
if [ &amp;quot;$photon_initrd&amp;quot; ]; then
initrd &amp;quot;/boot/&amp;quot;$photon_initrd
fi
}
# End /boot/grub2/grub.cfg
&lt;/code>&lt;/pre>&lt;p>Edit out &lt;code>net.ifnames=0&lt;/code>, but make no other changes to the file, and then save it.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Specify the types of policies that you want to use for predictable interface names by modifying the &lt;code>NamePolicy&lt;/code> option in &lt;code>/lib/systemd/network/99-default.link&lt;/code>. The file contents are as follows:&lt;/p>
&lt;pre>&lt;code>cat /lib/systemd/network/99-default.link
[Link]
NamePolicy=kernel database
MACAddressPolicy=persistent
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;p>To use the &lt;code>ens&lt;/code> or &lt;code>enx&lt;/code> option, the &lt;code>slot&lt;/code> policy or the &lt;code>mac&lt;/code> policy can be added to the space-separated list of policies that follow the &lt;code>NamePolicy&lt;/code> option in the default link file, &lt;code>/lib/systemd/network/99-default.link&lt;/code>. The order of the policies matters. Photon OS applies the policy listed first before proceeding to the next policy if the first one fails.&lt;/p>
&lt;p>For example:&lt;/p>
&lt;pre>&lt;code>/lib/systemd/network/99-default.link
[Link]
NamePolicy=slot mac kernel database
MACAddressPolicy=persistent
&lt;/code>&lt;/pre>&lt;p>With the name policy specified in the above example, you might still have an Ethernet-style interface name if the two previous policies, &lt;code>slot&lt;/code> and &lt;code>mac&lt;/code>, fail.&lt;/p>
&lt;p>For information on setting name policies, see &lt;a href="https://www.freedesktop.org/software/systemd/man/systemd.link.html">systemd.link&amp;ndash;network device configuration&lt;/a>.&lt;/p></description></item><item><title>Docs: Inspecting the Status of Network Links with 'networkctl'</title><link>/docs/administration-guide/managing-network-configuration/inspecting-the-status-of-network-links-with-networkctl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/administration-guide/managing-network-configuration/inspecting-the-status-of-network-links-with-networkctl/</guid><description>
&lt;p>You can inspect information about network connections by using the &lt;code>networkctl&lt;/code> command. This can help you configure networking services and troubleshoot networking problems.&lt;/p>
&lt;p>You can progressively add options and arguments to the &lt;code>networkctl&lt;/code> command to move from general information about network connections to specific information about a network connection.&lt;/p>
&lt;h1 id="networkctl-command-without-options">networkctl Command Without Options&lt;/h1>
&lt;p>Run the &lt;code>networkctl&lt;/code> command without options to default to the list command:&lt;/p>
&lt;pre>&lt;code>networkctl
IDX LINK TYPE OPERATIONAL SETUP
1 lo loopback carrier unmanaged
2 eth0 ether routable configured
3 docker0 ether routable unmanaged
11 vethb0aa7a6 ether degraded unmanaged
4 links listed.
&lt;/code>&lt;/pre>
&lt;h2 id="networkctl-status-command">&amp;lsquo;networkctl status&amp;rsquo; Command&lt;/h2>
&lt;p>Run &lt;code>networkctl&lt;/code> with the status command to display the following information:&lt;/p>
&lt;pre>&lt;code>root@photon-rc [ ~ ]# &amp;gt; networkctl status
State: routable
Address: 10.197.103.56 on eno1
172.17.0.1 on docker0
fe80::20c:29ff:fe44:f92c on eno1
Gateway: 10.197.103.253 (Cisco Systems, Inc) on eno1
DNS: 10.142.7.1
10.132.7.1
10.166.17.90
NTP: 10.128.152.81
10.166.1.120
10.188.26.119
10.84.55.42
&lt;/code>&lt;/pre>&lt;p>You can see that there are active network links with IP addresses for not only the Ethernet connection but also a Docker container.&lt;/p>
&lt;h3 id="networkctl-status-command-with-network-link-option">&amp;lsquo;networkctl status&amp;rsquo; Command With Network Link Option&lt;/h3>
&lt;p>You can add a network link, such as the Ethernet connection, as the argument of the &lt;code>status&lt;/code> command to show specific information about the link:&lt;/p>
&lt;pre>&lt;code> root@photon-rc [ ~ ]# networkctl status ens33
* 2: ens33
Link File: /usr/lib/systemd/network/99-default.link
Network File: /usr/lib/systemd/network/10-eth.network
Type: ether
State: routable (configured)
Alternative Names: enp2s1
Path: pci-0000:02:01.0
Driver: e1000
Vendor: Intel Corporation
Model: 82545EM Gigabit Ethernet Controller (Copper) (PRO/1000 MT Single Port Adapter)
HW Address: 00:0c:29:5f:d1:39 (VMware, Inc.)
MTU: 1500 (min: 46, max: 16110)
QDisc: fq_codel
IPv6 Address Generation Mode: eui64
Queue Length (Tx/Rx): 1/1
Auto negotiation: yes
Speed: 1Gbps
Duplex: full
Port: tp
Address: 172.16.85.225 (DHCP4 via 172.16.85.254)
fe80::20c:29ff:fe5f:d139
Gateway: 172.16.85.2 (VMware, Inc.)
DNS: 172.16.85.2
DHCP4 Client ID: IAID:0x2b9434c1/DUID
DHCP6 Client DUID: DUID-EN/Vendor:0000ab11d258482fc7eee6510000
Feb 26 10:19:44 fedora systemd-networkd[650]: ens33: Link UP
Feb 26 10:19:44 fedora systemd-networkd[650]: ens33: Gained carrier
Feb 26 10:19:45 fedora systemd-networkd[650]: ens33: DHCPv4 address 172.16.85.225/24 via 172.16.85.2
Feb 26 10:19:46 fedora systemd-networkd[650]: ens33: Gained IPv6LL
&lt;/code>&lt;/pre>&lt;h3 id="networkctl-status-command-with-docker-option">&amp;lsquo;networkctl status&amp;rsquo; Command With Docker Option&lt;/h3>
&lt;p>You can add a Docker container as the argument of the &lt;code>status&lt;/code> command to show specific information about the container:&lt;/p>
&lt;pre>&lt;code>networkctl status docker0
* 3: docker0
Link File: /usr/lib/systemd/network/99-default.link
Network File: n/a
Type: ether
State: routable (unmanaged)
Driver: bridge
HW Address: 02:42:f0:f7:bd:81
MTU: 1500
Address: 172.17.0.1
fe80::42:f0ff:fef7:bd81
&lt;/code>&lt;/pre>&lt;p>In the example above, the state of the Docker container is unmanaged because Docker handles managing the networking for the containers without using systemd-resolved or systemd-networkd. Docker manages the container connection by using its bridge drive.&lt;/p>
&lt;p>For more information about &lt;code>networkctl&lt;/code> commands and options, see &lt;a href="https://www.freedesktop.org/software/systemd/man/networkctl.html">https://www.freedesktop.org/software/systemd/man/networkctl.html&lt;/a>.&lt;/p></description></item><item><title>Docs: Turning On Network Debugging</title><link>/docs/administration-guide/managing-network-configuration/turning-on-network-debugging/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/administration-guide/managing-network-configuration/turning-on-network-debugging/</guid><description>
&lt;p>You can set &lt;code>systemd-networkd&lt;/code> to work in debug mode so that you can analyze log files with debugging information to help troubleshoot networking problems.&lt;/p>
&lt;p>You can turn on network debugging by adding a drop-in file in &lt;code>/etc/systemd&lt;/code> to customize the default systemd configuration in &lt;code>/usr/lib/systemd&lt;/code>.&lt;/p>
&lt;p>&lt;strong>Procedure&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Run the following command as root to create a directory with the name &lt;code>systemd-networkd.service.d&lt;/code>, including the &lt;code>.d&lt;/code> extension:&lt;/p>
&lt;pre>&lt;code>&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;p>mkdir -p /etc/systemd/system/systemd-networkd.service.d/&lt;/p>
&lt;pre>&lt;code>
1. Run the following command as root to establish a `systemd` drop-in unit with a debugging configuration for the network service:
```
cat &amp;gt; /etc/systemd/system/systemd-networkd.service.d/override.conf
[Service]
Environment=SYSTEMD_LOG_LEVEL=debug
EOF
&lt;/code>&lt;/pre>&lt;ol>
&lt;li>
&lt;p>Reload the &lt;code>systemctl&lt;/code> daemon and restart the &lt;code>systemd-networkd&lt;/code> service for the changes to take effect:&lt;/p>
&lt;pre>&lt;code>&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;p>systemctl daemon-reload
systemctl restart systemd-networkd&lt;/p>
&lt;pre>&lt;code>
1. Verify your changes:
```
systemd-delta --type=extended
&lt;/code>&lt;/pre>&lt;ol>
&lt;li>
&lt;p>View the log files by running this command:&lt;/p>
&lt;pre>&lt;code>&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;p>journalctl -u systemd-networkd&lt;/p>
&lt;pre>&lt;code>
1. After debugging the network connections, turn debugging off by deleting the drop-in file:
```
rm /etc/systemd/system/systemd-networkd.service.d/10-loglevel-debug.conf
&lt;/code>&lt;/pre></description></item><item><title>Docs: Mounting a Network File System</title><link>/docs/administration-guide/managing-network-configuration/mounting-a-network-file-system/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/administration-guide/managing-network-configuration/mounting-a-network-file-system/</guid><description>
&lt;p>To mount a network file system, Photon OS requires &lt;code>nfs-utils&lt;/code>. The &lt;code>nfs-utils&lt;/code> package contains the daemon, userspace server, and client tools for the kernel Network File System (NFS). The tools include &lt;code>mount.nfs&lt;/code>, &lt;code>umount.nfs&lt;/code>, and &lt;code>showmount&lt;/code>.&lt;/p>
&lt;p>The &lt;code>nfs-utils&lt;/code> package is installed by default in the full version of Photon OS but not in the minimal version. To install &lt;code>nfs-utils&lt;/code> in the minimal version, run the following command as root:&lt;/p>
&lt;pre>&lt;code>tdnf install nfs-utils
&lt;/code>&lt;/pre>&lt;p>For instructions on how to use &lt;code>nfs-utils&lt;/code> to share files over a network, see &lt;a href="../../../user-guide/mounting-remote-file-systems/">Photon OS nfs-utils&lt;/a>.&lt;/p></description></item><item><title>Docs: Network Configuration Manager - C API</title><link>/docs/administration-guide/managing-network-configuration/netmgr.c/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/administration-guide/managing-network-configuration/netmgr.c/</guid><description>
&lt;p>Photon OS provides a C API for the Network Configuration Manager.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#about-the-network-configuration-manager-c-api">About the Network Configuration Manager C API&lt;/a>&lt;/li>
&lt;li>&lt;a href="#interface-configuration-apis">Interface Configuration APIs&lt;/a>&lt;/li>
&lt;li>&lt;a href="#ip-address-configuration-apis">IP Address Configuration APIs&lt;/a>&lt;/li>
&lt;li>&lt;a href="#route-configuration-apis">Route Configuration APIs&lt;/a>&lt;/li>
&lt;li>&lt;a href="#dns-configuration-apis">DNS Configuration APIs&lt;/a>&lt;/li>
&lt;li>&lt;a href="#dhcp-options-duid-and-iaid-configuration-apis">DHCP Options DUID and IAID Configuration APIs&lt;/a>&lt;/li>
&lt;li>&lt;a href="#ntp-configuration-apis">NTP Configuration APIs&lt;/a>&lt;/li>
&lt;li>&lt;a href="#service-management-apis">Service Management APIs&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="about-the-network-configuration-manager-c-api">About the Network Configuration Manager C API&lt;/h1>
&lt;p>Use the Network Configuration Manager C API to simplify common network configuration tasks for:&lt;/p>
&lt;ul>
&lt;li>interfaces&lt;/li>
&lt;li>IP addresses (IPv4 and IPv6 addresses)&lt;/li>
&lt;li>routes&lt;/li>
&lt;li>DNS server and domain settings&lt;/li>
&lt;li>DHCP DUID and IAID settings&lt;/li>
&lt;li>NTP server settings&lt;/li>
&lt;li>service management&lt;/li>
&lt;li>object parameters (interfaces and files)&lt;/li>
&lt;/ul>
&lt;h2 id="header-file">Header File&lt;/h2>
&lt;p>Header files for all the C APIs are defined in the following location:&lt;/p>
&lt;p>&lt;a href="https://github.com/vmware/pmd/tree/master/include">https://github.com/&lt;/a> &lt;a href="https://github.com/vmware/pmd/tree/master/include">vmware&lt;/a> &lt;a href="https://github.com/vmware/pmd/tree/master/include">/pmd/tree/master/include&lt;/a>&lt;/p>
&lt;p>To install the Network Configuration Manager header file, run the following command:&lt;/p>
&lt;p>&lt;code>tdnf install netmgmt-devel&lt;/code>
n
Once installed, you can reference the header file in the following location:&lt;/p>
&lt;p>&lt;code>/usr/include/netmgmt/network-config-manager.h&lt;/code>&lt;/p>
&lt;h2 id="freeing-memory">Freeing Memory&lt;/h2>
&lt;p>For all get APIs that take a pointer-to-pointer parameter, the caller has the responsibility to free the memory upon successful response from API by calling free().&lt;/p>
&lt;h2 id="error-codes">Error Codes&lt;/h2>
&lt;p>All C API calls return 0 for success, or one of the following error codes for failure.&lt;/p>
&lt;ul>
&lt;li>4097 - NM_ERR_INVALID_PARAMETER&lt;/li>
&lt;li>4098 - NM_ERR_NOT_SUPPORTED&lt;/li>
&lt;li>4099 - NM_ERR_OUT_OF_MEMORY&lt;/li>
&lt;li>4100 - NM_ERR_VALUE_NOT_FOUND&lt;/li>
&lt;li>4101 - NM_ERR_VALUE_EXISTS&lt;/li>
&lt;li>4102 - NM_ERR_INVALID_INTERFACE&lt;/li>
&lt;li>4103 - NM_ERR_INVALID_ADDRESS&lt;/li>
&lt;li>4104 - NM_ERR_INVALID_MODE&lt;/li>
&lt;li>4105 - NM_ERR_BAD_CONFIG_FILE&lt;/li>
&lt;li>4106 - NM_ERR_WRITE_FAILED&lt;/li>
&lt;li>4107 - NM_ERR_TIME_OUT&lt;/li>
&lt;li>4108 - NM_ERR_DHCP_TIME_OUT&lt;/li>
&lt;/ul>
&lt;p>Use nm_get_error_info to retrieve information about an error code.&lt;/p>
&lt;pre>&lt;code> const char \*
nm_get_error_info(
uint32_t nmErrCode
);``
&lt;/code>&lt;/pre>&lt;h1 id="interface-configuration-apis">Interface Configuration APIs&lt;/h1>
&lt;p>The Photon OS network manager C API enables you to manage network interfaces.&lt;/p>
&lt;h2 id="structure-declarations">Structure Declarations&lt;/h2>
&lt;h3 id="link-mode">Link Mode&lt;/h3>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Link mode. Available settings:&lt;/p>
&lt;ul>
&lt;li>&lt;code>LINK_AUTO&lt;/code> - the specified interface is managed and configured by systemd network manager&lt;/li>
&lt;li>&lt;code>LINK_MANUAL&lt;/code> - systemd will not bring up or configure the specified interface&lt;/li>
&lt;li>&lt;code>LINK_MODE_UNKNOWN&lt;/code> - the link mode is unknown&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> typedef enum _NET_LINK_MODE
{
LINK_AUTO = 0,
LINK_MANUAL,
LINK_MODE_UNKNOWN
} NET_LINK_MODE;``
&lt;/code>&lt;/pre>&lt;h3 id="link-state">Link State&lt;/h3>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Link state. Available settings:&lt;/p>
&lt;ul>
&lt;li>&lt;code>LINK_DOWN&lt;/code> - the link is being administratively down or has no carrier signal&lt;/li>
&lt;li>&lt;code>LINK_UP&lt;/code> - the link is configured up and has carrier signal&lt;/li>
&lt;li>&lt;code>LINK_STATE_UNKNOWN&lt;/code> - link state is unknown&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> typedef enum _NET_LINK_STATE
{
LINK_DOWN = 0,
LINK_UP,
LINK_STATE_UNKNOWN,
} NET_LINK_STATE;
&lt;/code>&lt;/pre>&lt;h3 id="link-information">Link Information&lt;/h3>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Link information. Includes the following information:&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>pszMacAddress&lt;/code> - interface hardware address specified in a colon-separated format (for example: &amp;ldquo;00:0c:29:99:a5:7b&amp;rdquo;)&lt;/li>
&lt;li>&lt;code>mtu&lt;/code> - maximum transmission unit (MTU)&lt;/li>
&lt;li>&lt;code>mode&lt;/code> - link mode (see above)&lt;/li>
&lt;li>&lt;code>state&lt;/code> - link state (see above)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> typedef struct _NET_LINK_INFO
{
struct _NET_LINK_INFO \*pNext;
char \*pszInterfaceName;
char \*pszMacAddress;
uint32_t mtu;
NET_LINK_MODE mode;
NET_LINK_STATE state;
} NET_LINK_INFO, \*PNET_LINK_INFO;
&lt;/code>&lt;/pre>&lt;h2 id="nm_set_link_mac_addr">nm_set_link_mac_addr&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Set the MAC address of the interface.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_set_link_mac_addr(
const char \*pszInterfaceName,
const char \*pszMacAddress
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>pszMacAddress&lt;/code> - interface hardware address specified in a colon-separated format (for example: &amp;ldquo;00:0c:29:99:a5:7b&amp;rdquo;)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_get_link_mac_addr">nm_get_link_mac_addr&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Get the MAC address of the interface.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_get_link_mac_addr(
const char \*pszInterfaceName,
char \*\*ppszMacAddress
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>ppszMacAddress&lt;/code> - interface hardware address specified in a colon-separated format (for example: &amp;ldquo;00:0c:29:99:a5:7b&amp;rdquo;)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_set_link_mode">nm_set_link_mode&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Set the mode of the interface (auto or manual).&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_set_link_mode(
const char \*pszInterfaceName,
NET_LINK_MODE mode
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>mode&lt;/code> - link mode. One of the following values:
&lt;ul>
&lt;li>&lt;code>LINK_AUTO&lt;/code> - the specified interface is managed and configured by systemd network manager&lt;/li>
&lt;li>&lt;code>LINK_MANUAL&lt;/code> - systemd will not bring up or configure the specified interface&lt;/li>
&lt;li>&lt;code>LINK_MODE_UNKNOWN&lt;/code> - the link mode is unknown&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_get_link_mode">nm_get_link_mode&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Get the mode of the interface (auto or manual).&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_get_link_mode(
const char \*pszInterfaceName,
NET_LINK_MODE \*pLinkMode
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>pLinkMode&lt;/code> - link mode. One of the following values:
&lt;ul>
&lt;li>&lt;code>LINK_AUTO&lt;/code> - the specified interface is managed and configured by systemd network manager&lt;/li>
&lt;li>&lt;code>LINK_MANUAL&lt;/code> - systemd will not bring up or configure the specified interface&lt;/li>
&lt;li>&lt;code>LINK_MODE_UNKNOWN&lt;/code> - the link mode is unknown&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_set_link_mtu">nm_set_link_mtu&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Set the maximum transmission unit (MTU) of the interface.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_set_link_mtu(
const char \*pszInterfaceName,
uint32_t mtu
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>mtu&lt;/code> - maximum transmission unit (MTU)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_get_link_mtu">nm_get_link_mtu&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Get the maximum transmission unit (MTU) of the interface.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>nm_get_link_mtu
uint32_t
nm_get_link_mtu(
const char \*pszInterfaceName,
uint32_t \*pMtu
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>pMtu&lt;/code> - maximum transmission unit (MTU)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_set_link_state">nm_set_link_state&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Set the link state of the interface (up or down).&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> uint32_t
nm_set_link_state(
const char \*pszInterfaceName,
NET_LINK_STATE state
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>state&lt;/code> - link state. One of the following values:
&lt;ul>
&lt;li>&lt;code>LINK_DOWN&lt;/code> - the link is being administratively down or has no carrier signal.&lt;/li>
&lt;li>&lt;code>LINK_UP&lt;/code> - the link is configured up and has carrier signal.&lt;/li>
&lt;li>&lt;code>LINK_STATE_UNKNOWN&lt;/code> - the link state is unknown&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_get_link_state">nm_get_link_state&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Get the link state of the interface (up or down).&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_get_link_state(
const char \*pszInterfaceName,
NET_LINK_STATE \*pLinkState
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>pLinkState&lt;/code> - link state. One of the following values:
&lt;ul>
&lt;li>&lt;code>LINK_DOWN&lt;/code> - the link is being administratively down or has no carrier signal&lt;/li>
&lt;li>&lt;code>LINK_UP&lt;/code> - the link is configured up and has carrier signal&lt;/li>
&lt;li>&lt;code>LINK_STATE_UNKNOWN&lt;/code> - the link state is unknown&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_ifup">nm_ifup&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Set the specified interface state to UP. Additionally, if the interface is configured to have an IP address, it waits for the interface to acquire the IP address, and then updates neighbors of its IP address via the address resolution protocol (ARP) messages.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> uint32_t
nm_ifup(
const char \*pszInterfaceName
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_ifdown">nm_ifdown&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Set the specified interface state to DOWN.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_ifdown(
const char \*pszInterfaceName
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_get_link_info">nm_get_link_info&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Get link information for the interface. The caller is responsible for freeing ppLinkInfo by calling nm_free_link_info.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_get_link_info(
const char \*pszInterfaceName,
NET_LINK_INFO \*\*ppLinkInfo
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>ppLinkInfo&lt;/code>, which includes the following information:
&lt;ul>
&lt;li>*&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>*&lt;code>pszMacAddress&lt;/code> - interface hardware address specified in a colon-separated format (for example: &amp;ldquo;00:0c:29:99:a5:7b&amp;rdquo;)&lt;/li>
&lt;li>&lt;code>mtu&lt;/code> - maximum transmission unit (MTU)&lt;/li>
&lt;li>&lt;code>mode&lt;/code> - One of the following values:
&lt;ul>
&lt;li>&lt;code>LINK_AUTO&lt;/code> - the specified interface is managed and configured by systemd network manager&lt;/li>
&lt;li>&lt;code>LINK_MANUAL&lt;/code> - systemd will not bring up or configure the specified interface&lt;/li>
&lt;li>&lt;code>LINK_MODE_UNKNOWN&lt;/code> - the link mode is unknown&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>state&lt;/code> - One of the following values:
&lt;ul>
&lt;li>&lt;code>LINK_DOWN&lt;/code> - the link is being administratively down or has no carrier signal&lt;/li>
&lt;li>&lt;code>LINK_UP&lt;/code> - the link is configured up and has carrier signal&lt;/li>
&lt;li>&lt;code>LINK_STATE_UNKNOWN&lt;/code> - the link state is unknown&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_free_link_info">nm_free_link_info&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Frees the NET_LINK_INFO structure returned by a successful nm_get_link_info call.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>void
nm_free_link_info(
NET_LINK_INFO \*pNetLinkInfo
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pNetLinkInfo&lt;/code>, which includes the following information:
&lt;ul>
&lt;li>*&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>*&lt;code>pszMacAddress&lt;/code> - interface hardware address specified in a colon-separated format (for example: &amp;ldquo;00:0c:29:99:a5:7b&amp;rdquo;)&lt;/li>
&lt;li>&lt;code>mtu&lt;/code> - maximum transmission unit (MTU)&lt;/li>
&lt;li>&lt;code>mode&lt;/code> - One of the following values:
&lt;ul>
&lt;li>&lt;code>LINK_AUTO&lt;/code> - the specified interface is managed and configured by systemd network manager&lt;/li>
&lt;li>&lt;code>LINK_MANUAL&lt;/code> - systemd will not bring up or configure the specified interface&lt;/li>
&lt;li>&lt;code>LINK_MODE_UNKNOWN&lt;/code> - the link mode is unknown&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>state&lt;/code> - One of the following values:
&lt;ul>
&lt;li>&lt;code>LINK_DOWN&lt;/code> - the link is being administratively down or has no carrier signal&lt;/li>
&lt;li>&lt;code>LINK_UP&lt;/code> - the link is configured up and has carrier signal&lt;/li>
&lt;li>&lt;code>LINK_STATE_UNKNOWN&lt;/code> - the link state is unknown&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h1 id="ip-address-configuration-apis">IP Address Configuration APIs&lt;/h1>
&lt;p>The Photon OS network manager C API enables you to manage IP addresses for interfaces that are managed by systemd network manager.&lt;/p>
&lt;h2 id="structure-declarations-1">Structure Declarations&lt;/h2>
&lt;h3 id="ip-address-mode">IP Address Mode&lt;/h3>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Defines the IP address mode. One of the following values:&lt;/p>
&lt;ul>
&lt;li>&lt;code>IPV4_ADDR_MODE_NONE&lt;/code> - no IPv4 address configured on the interface&lt;/li>
&lt;li>&lt;code>IPV4_ADDR_MODE_STATIC&lt;/code> - the interface is configured with a static IPv4 address&lt;/li>
&lt;li>&lt;code>IPV4_ADDR_MODE_DHCP&lt;/code> - the interface is configured with a DHCP IPv4 address&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> typedef enum _NET_IPV4_ADDR_MODE
{
IPV4_ADDR_MODE_NONE = 0,
IPV4_ADDR_MODE_STATIC,
IPV4_ADDR_MODE_DHCP,
IPV4_ADDR_MODE_MAX
} NET_IPV4_ADDR_MODE;
&lt;/code>&lt;/pre>&lt;h3 id="address-type">Address Type&lt;/h3>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Defines the type of IP address. One of the following options:&lt;/p>
&lt;ul>
&lt;li>&lt;code>STATIC_IPV4&lt;/code> - static IPv4 address&lt;/li>
&lt;li>&lt;code>STATIC_IPV6&lt;/code> - static IPv6 address&lt;/li>
&lt;li>&lt;code>DHCP_IPV4&lt;/code> - DHCP IPv4 address&lt;/li>
&lt;li>&lt;code>DHCP_IPV6&lt;/code> - DHCP IPv6 address&lt;/li>
&lt;li>&lt;code>AUTO_IPV6&lt;/code> - stateless dynamic IPv6 address&lt;/li>
&lt;li>&lt;code>LINK_LOCAL_IPV6&lt;/code> - link local IPv6 address&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> typedef enum _NET_ADDR_TYPE
{
STATIC_IPV4 = 0x00000001,
STATIC_IPV6 = 0x00000002,
DHCP_IPV4 = 0x00000010,
DHCP_IPV6 = 0x00000020,
AUTO_IPV6 = 0x00000040,
LINK_LOCAL_IPV6 = 0x00000080,
} NET_ADDR_TYPE;
&lt;/code>&lt;/pre>&lt;h3 id="ip-addresses">IP Addresses&lt;/h3>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Defines IP addresses.&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>type&lt;/code> - address type&lt;/li>
&lt;li>&lt;code>pszIPAddrPrefix&lt;/code> - IP address&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Declarations&lt;/strong>&lt;/p>
&lt;pre>&lt;code> typedef struct _NET_IP_ADDR
{
char \*pszInterfaceName;
NET_ADDR_TYPE type;
char \*pszIPAddrPrefix;
} NET_IP_ADDR, \*PNET_IP_ADDR;
&lt;/code>&lt;/pre>&lt;h2 id="nm_set_ipv4_addr_gateway">nm_set_ipv4_addr_gateway&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Set the IPv4 address and (optionally) the default gateway address for the interface.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> uint32_t
nm_set_ipv4_addr_gateway(
const char \*pszInterfaceName,
NET_IPV4_ADDR_MODE mode,
const char \*pszIPv4AddrPrefix,
const char \*pszIPv4Gateway
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>mode&lt;/code> - IP address mode; one of the following values:
&lt;ul>
&lt;li>&lt;code>IPV4_ADDR_MODE_NONE&lt;/code>&lt;/li>
&lt;li>&lt;code>IPV4_ADDR_MODE_STATIC&lt;/code>&lt;/li>
&lt;li>&lt;code>IPV4_ADDR_MODE_DHCP&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>pszIPv4AddrPrefix&lt;/code> - IPv4 address specified in dot-decimal / prefix notation (for example, 10.10.10.101/23). If the prefix is not specified, then a /32 prefix is assumed.&lt;/li>
&lt;li>&lt;code>pszIPv4Gateway&lt;/code> - IPv4 gateway (optional) specified in the dot-decimal format (for example,10.10.20.30).&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_get_ipv4_addr_gateway">nm_get_ipv4_addr_gateway&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Get the IPv4 address and the default gateway address for the interface.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_get_ipv4_addr_gateway(
const char \*pszInterfaceName,
NET_IPV4_ADDR_MODE \*pMode,
char \*\*ppszIPv4AddrPrefix,
char \*\*ppszIPv4Gateway
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>pmode&lt;/code> - IP mode; one of the following values:
&lt;ul>
&lt;li>&lt;code>IPV4_ADDR_MODE_NONE&lt;/code>&lt;/li>
&lt;li>&lt;code>IPV4_ADDR_MODE_STATIC&lt;/code>&lt;/li>
&lt;li>&lt;code>IPV4_ADDR_MODE_DHCP&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>ppszIPv4AddrPrefix&lt;/code> - IPv4 address returned in dot-decimal / prefix notation (for example, 10.10.10.101/23). If the prefix is not specified, then a /32 prefix is assumed.&lt;/li>
&lt;li>&lt;code>ppszIPv4Gateway&lt;/code> - IPv4 gateway (optional) returned in the dot-decimal format (for example,10.10.10.250).&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_add_static_ipv6_addr">nm_add_static_ipv6_addr&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Add an IPv6 address to the specified interface.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_add_static_ipv6_addr(
const char \*pszInterfaceName,
const char \*pszIPv6AddrPrefix
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>pszIPv6AddrPrefix&lt;/code> - IPv6 address specified in the standard colon-separated IPv6 address format followed by the prefix (for example, 2010:a1:b2::25/64). If the not prefix is specified, then a /128 prefix is assumed.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_delete_static_ipv6_addr">nm_delete_static_ipv6_addr&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Delete a static IPv6 address from the interface.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_delete_static_ipv6_addr(
const char \*pszInterfaceName,
const char \*pszIPv6AddrPrefix
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>pszIPv6AddrPrefix&lt;/code> - IPv6 address specified in the standard colon-separated IPv6 address format followed by the prefix (for example, 2010:a1:b2::25/64). If the not prefix is specified, then a /128 prefix is assumed.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_set_ipv6_addr_mode">nm_set_ipv6_addr_mode&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Set the mode for the interface.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_set_ipv6_addr_mode(
const char \*pszInterfaceName,
uint32_t enableDhcp,
uint32_t enableAutoconf
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>enableDhcp&lt;/code> - enable (1) or disable (0) DHCP; enabling configures the interface to acquire a DHCP IPv6 address.&lt;/li>
&lt;li>&lt;code>enableAutoconf&lt;/code> - enable (1) or disable (0) autoconf; enabling configures the interface to acquire a stateless autoconfiguration IPv6 address.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_get_ipv6_addr_mode">nm_get_ipv6_addr_mode&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Get the mode for the interface.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> uint32_t
nm_get_ipv6_addr_mode(
const char \*pszInterfaceName,
uint32_t \*pDhcpEnabled,
uint32_t \*pAutoconfEnabled
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>pDhcpEnabled&lt;/code> - returns whether IPv6 DHCP is enabled (1) or disabled (0).&lt;/li>
&lt;li>&lt;code>pAutoconfEnabled&lt;/code> - returns whether IPv6 stateless autoconfiguration is enabled (1) or disabled (0).&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_get_ip_addr">nm_get_ip_addr&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Get the IP address for the interface.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_get_ip_addr(
const char \*pszInterfaceName,
uint32_t addrTypes,
size_t \*pCount,
NET_IP_ADDR \*\*\*pppIpAddrList
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>addrTypes&lt;/code> - type of IP address; one of the following values:
&lt;ul>
&lt;li>&lt;code>STATIC_IPV4&lt;/code>&lt;/li>
&lt;li>&lt;code>STATIC_IPV6&lt;/code>&lt;/li>
&lt;li>&lt;code>DHCP_IPV4&lt;/code>&lt;/li>
&lt;li>&lt;code>DHCP_IPV6&lt;/code>&lt;/li>
&lt;li>&lt;code>AUTO_IPV6&lt;/code>&lt;/li>
&lt;li>&lt;code>LINK_LOCAL_IPV6&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>pCount&lt;/code> - number of IP address structures in the pppIpAddrList array returned by the API call.&lt;/li>
&lt;li>&lt;code>pppIpAddrList&lt;/code> - array of NET_IP_ADDR elements that includes the following:
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code>&lt;/li>
&lt;li>&lt;code>type&lt;/code>&lt;/li>
&lt;li>&lt;code>pszIPAddrPrefix&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_set_ipv6_gateway">nm_set_ipv6_gateway&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Set the default IPv6 gateway for the interface.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> uint32_t
nm_set_ipv6_gateway(
const char \*pszInterfaceName,
const char \*pszIPv6Gateway
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>pszIPv6Gateway&lt;/code> - IPv6 gateway specified in the standard colon-separated IPv6 address format (for example, 2010:125::100)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_get_ipv6_gateway">nm_get_ipv6_gateway&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Get the default IPv6 gateway for the interface.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> uint32_t
nm_get_ipv6_gateway(
const char \*pszInterfaceName,
char \*\*ppszIPv6Gateway
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>ppszIPv6Gateway&lt;/code> - IPv6 gateway specified in the standard colon-separated IPv6 address format (for example, 2010:125::100)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h1 id="route-configuration-apis">Route Configuration APIs&lt;/h1>
&lt;p>The Photon OS network manager C API enables you to manage static IP routes configuration.&lt;/p>
&lt;h2 id="structure-declarations-2">Structure Declarations&lt;/h2>
&lt;h3 id="route-scope">Route Scope&lt;/h3>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Defines the scope of a route. One of the following options.&lt;/p>
&lt;ul>
&lt;li>&lt;code>GLOBAL_ROUTE&lt;/code> - route to a destination one or more hops away&lt;/li>
&lt;li>&lt;code>LINK_ROUTE&lt;/code> - route to a destination on the local network&lt;/li>
&lt;li>&lt;code>HOST_ROUTE&lt;/code> - route to a destination address on the local host&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> typedef enum _NET_ROUTE_SCOPE
{
GLOBAL_ROUTE = 0,
LINK_ROUTE,
HOST_ROUTE,
NET_ROUTE_SCOPE_MAX
} NET_ROUTE_SCOPE;
&lt;/code>&lt;/pre>&lt;h3 id="ip-route">IP Route&lt;/h3>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Defines an IP route. Includes the following information:&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface through which the specified destination network can be reached&lt;/li>
&lt;li>&lt;code>pszDestNetwork&lt;/code> - destination IP network reached by the specified route&lt;/li>
&lt;li>&lt;code>pszSourceNetwork&lt;/code> - source network for the specified route&lt;/li>
&lt;li>&lt;code>pszGateway&lt;/code> - IP gateway through which the specified destination network can be reached&lt;/li>
&lt;li>&lt;code>scope&lt;/code> - scope of this route entry; one of the following values: GLOBAL_ROUTE, LINK_ROUTE, or HOST_ROUTE as defined above&lt;/li>
&lt;li>&lt;code>metric&lt;/code> - metric of this route, an unsigned integer&lt;/li>
&lt;li>&lt;code>table&lt;/code> - identifier for the route table to which this route belongs.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> typedef struct _NET_IP_ROUTE
{
char \*pszInterfaceName;
char \*pszDestNetwork;
char \*pszSourceNetwork;
char \*pszGateway;
NET_ROUTE_SCOPE scope;
uint32_t metric;
uint32_t table;
} NET_IP_ROUTE, \*PNET_IP_ROUTE;
&lt;/code>&lt;/pre>&lt;h2 id="nm_add_static_ip_route">nm_add_static_ip_route&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Add a static IP route.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_add_static_ip_route(
NET_IP_ROUTE \*pRoute
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pRoute&lt;/code> - static IP route&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_delete_static_ip_route">nm_delete_static_ip_route&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Delete a static IP route.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> uint32_t
nm_delete_static_ip_route(
NET_IP_ROUTE \*pRoute
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pRoute&lt;/code> - static IP route&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_get_static_ip_routes">nm_get_static_ip_routes&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Get the static IP routes for an interface.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> uint32_t
nm_get_static_ip_routes(
const char \*pszInterfaceName,
size_t \*pCount,
NET_IP_ROUTE \*\*\*pppRouteList
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>pCount&lt;/code> - number of NET_IP_ROUTE elements returned in the pppRouteList array by the API call upon success&lt;/li>
&lt;li>&lt;code>pppRouteList&lt;/code> - array of static IP routes&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h1 id="dns-configuration-apis">DNS Configuration APIs&lt;/h1>
&lt;p>The Photon OS network manager C API enables you to manage the DNS and Domains configuration.&lt;/p>
&lt;h2 id="structure-declarations-3">Structure Declarations&lt;/h2>
&lt;h3 id="dns-mode">DNS Mode&lt;/h3>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>DNS mode. Any of the following values:&lt;/p>
&lt;ul>
&lt;li>&lt;code>DNS_MODE_INVALID&lt;/code> - DNS mode is unknown&lt;/li>
&lt;li>&lt;code>STATIC_DNS&lt;/code> - DNS servers are statically configured&lt;/li>
&lt;li>&lt;code>DHCP_DNS&lt;/code> - DNS servers configuration is acquired from DHCP protocol.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> typedef enum _NET_DNS_MODE
{
DNS_MODE_INVALID = 0,
STATIC_DNS,
DHCP_DNS,
DNS_MODE_MAX,
} NET_DNS_MODE;
&lt;/code>&lt;/pre>&lt;h2 id="nm_set_dns_servers">nm_set_dns_servers&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Set the DNS servers list for the interface.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_set_dns_servers(
const char \*pszInterfaceName,
NET_DNS_MODE mode,
size_t count,
const char \*\*ppszDnsServers
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name (optional, can be NULL)&lt;/li>
&lt;li>&lt;code>mode&lt;/code> - DNS mode. One of the following values:
&lt;ul>
&lt;li>&lt;code>DNS_MODE_INVALID&lt;/code> = 0&lt;/li>
&lt;li>&lt;code>DNS_MODE_MA&lt;/code>&lt;/li>
&lt;li>&lt;code>DHCP_DNS&lt;/code>&lt;/li>
&lt;li>&lt;code>STATIC_DNS&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>count&lt;/code> - number of NUL terminated DNS server entries passed in the ppszDnsServers array to the API call (for example, 10.10.10.200 or 2020::40)&lt;/li>
&lt;li>&lt;code>ppszDnsServers&lt;/code> - array of DNS servers&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_add_dns_server">nm_add_dns_server&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Add a server to the DNS servers list associated with an interface.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_add_dns_server(
const char \*pszInterfaceName,
const char \*pszDnsServer
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name (optional, can be NULL)&lt;/li>
&lt;li>&lt;code>ppszDnsServer&lt;/code> - server to add to the DNS server list&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_delete_dns_server">nm_delete_dns_server&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Delete a server from the DNS servers list associated with an interface.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> uint32_t
nm_delete_dns_server(
const char \*pszInterfaceName,
const char \*pszDnsServer
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name (optional, can be NULL)&lt;/li>
&lt;li>&lt;code>ppszDnsServer&lt;/code> - server to remove from the DNS server list&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_get_dns_servers">nm_get_dns_servers&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Get the the DNS servers list for the interface.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_get_dns_servers(
const char \*pszInterfaceName,
NET_DNS_MODE \*pMode,
size_t \*pCount,
char \*\*\*pppszDnsServers
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name (optional, can be NULL)&lt;/li>
&lt;li>&lt;code>pMode&lt;/code> - DNS mode. One of the following values:
&lt;ul>
&lt;li>&lt;code>DNS_MODE_INVALID&lt;/code>&lt;/li>
&lt;li>&lt;code>DHCP_DNS&lt;/code>&lt;/li>
&lt;li>&lt;code>STATIC_DNS&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>pCount&lt;/code> - number of NUL terminated DNS server entries in the pppszDnsServers array returned by the API call (for example, 10.10.10.200 or 2020::40)&lt;/li>
&lt;li>&lt;code>pppszDnsServers&lt;/code> - array of DNS servers&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_set_dns_domains">nm_set_dns_domains&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Set the DNS domain list.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_set_dns_domains(
const char \*pszInterfaceName,
size_t count,
const char \*\*ppszDnsDomains
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name (optional, can be NULL)&lt;/li>
&lt;li>&lt;code>count&lt;/code> - number of DNS domains specified in the ppszDnsDomains array to the API call (for example, if count = 2, then there are two elements: ppszDnsDomains[0] and ppszDnsDomains[1])&lt;/li>
&lt;li>&lt;code>ppszDnsDomains&lt;/code> - array of DNS domains&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_add_dns_domain">nm_add_dns_domain&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Add a DNS domain to the DNS domain list.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_add_dns_domain(
const char \*pszInterfaceName,
const char \*pszDnsDomain
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name (optional, can be NULL)&lt;/li>
&lt;li>&lt;code>pszDnsDomain&lt;/code> - DNS domain to add to the list&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_delete_dns_domain">nm_delete_dns_domain&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Delete a DNS domain from the DNS domain list.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_delete_dns_domain(
const char \*pszInterfaceName,
const char \*pszDnsDomain
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name (optional, can be NULL)&lt;/li>
&lt;li>&lt;code>pszDnsDomain&lt;/code> - DNS domain to remove from the list&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_get_dns_domains">nm_get_dns_domains&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Get the list of DNS domains.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_get_dns_domains(
const char \*pszInterfaceName,
size_t \*pCount,
char \*\*\*pppszDnsDomains
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name (optional, can be NULL)&lt;/li>
&lt;li>&lt;code>pCount&lt;/code> - number of DNS domains returned in the pppszDnsDomains from the API call (for example, if count = 2, then there are two elements: ppszDnsDomains[0] and ppszDnsDomains[1])&lt;/li>
&lt;li>&lt;code>pppszDnsDomains&lt;/code> - array of DNS domains&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h1 id="dhcp-options-duid-and-iaid-configuration-apis">DHCP Options DUID and IAID Configuration APIs&lt;/h1>
&lt;p>The Photon OS network manager C API enables you to manage DHCP DUID and Interface IAID.&lt;/p>
&lt;h2 id="nm_set_iaid">nm_set_iaid&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Set the IAID for the interface.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_set_iaid(
const char \*pszInterfaceName,
uint32_t iaid
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>iaid&lt;/code> - interface association identifier (IAID)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_get_iaid">nm_get_iaid&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Get the IAID for the interface.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_get_iaid(
const char \*pszInterfaceName,
uint32_t \*pIaid
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>pIaid&lt;/code> - interface association identifier (IAID)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_set_duid">nm_set_duid&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Set the DUID for the interface.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_set_duid(
const char \*pszInterfaceName,
const char \*pszDuid
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name (optional, specify NULL to set system global DUID configuration)&lt;/li>
&lt;li>&lt;code>pszDuid&lt;/code> - DHCP unique identifier (DUID)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_get_duid">nm_get_duid&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Get the DUID for the interface.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_get_duid(
const char \*pszInterfaceName,
char \*\*ppszDuid
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name (optional, specify NULL to query system global DUID configuration)&lt;/li>
&lt;li>&lt;code>ppszDuid&lt;/code> - DHCP unique identifier (DUID)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h1 id="ntp-configuration-apis">NTP Configuration APIs&lt;/h1>
&lt;p>The Photon OS network manager C API enables you to manage NTP servers configured for the system.&lt;/p>
&lt;h2 id="nm_set_ntp_servers">nm_set_ntp_servers&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Set the list of NTP servers.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> uint32_t
nm_set_ntp_servers(
size_t count,
const char \*\*ppszNtpServers
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>count&lt;/code> - number of NTP servers in the ppszNtpServers array passed to the API call.&lt;/li>
&lt;li>&lt;code>ppszNtpServers&lt;/code> - array of NTP servers&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_add_ntp_servers">nm_add_ntp_servers&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Add a server to the NTP servers list.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> uint32_t
nm_add_ntp_servers(
size_t count,
const char \*\*ppszNtpServers
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>count&lt;/code> - number of NTP servers to add (specified in the ppszNtpServers array) passed to the API call.&lt;/li>
&lt;li>&lt;code>ppszNtpServers&lt;/code> - array of NTP servers to add&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_delete_ntp_servers">nm_delete_ntp_servers&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Delete a server from the NTP servers list.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> uint32_t
nm_delete_ntp_servers(
size_t count,
const char \*\*ppszNtpServers
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>count&lt;/code> - number of NTP servers to delete (specified in the ppszNtpServers array) passed to the API call&lt;/li>
&lt;li>&lt;code>ppszNtpServers&lt;/code> - array of NTP servers to delete&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_get_ntp_servers">nm_get_ntp_servers&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Get the NTP servers list.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> uint32_t
nm_get_ntp_servers(
size_t \*pCount,
char \*\*\*pppszNtpServers
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pCount&lt;/code> - number of NTP servers in the pppszNtpServers array returned from the API call&lt;/li>
&lt;li>&lt;code>pppszNtpServers&lt;/code> - array of NTP servers&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;p>Other APIs&lt;/p>
&lt;h2 id="nm_set_hostname">nm_set_hostname&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Set the host name for the system.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> uint32_t
nm_set_hostname(
const char \*pszHostname
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszHostname&lt;/code> - host name&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_get_hostname">nm_get_hostname&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Get the host name for the system.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> uint32_t
nm_get_hostname(
char \*\*ppszHostname
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ppszHostname&lt;/code> - host name&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_wait_for_link_up">nm_wait_for_link_up&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Wait for the specified interface to come up.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> uint32_t
nm_wait_for_link_up(
const char \*pszInterfaceName,
uint32_t timeout
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>timeout&lt;/code> - maximum time (in seconds) to wait (until the link is up) before timing out of the request; specify 0 for no timeout (wait indefinitely)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_wait_for_ip">nm_wait_for_ip&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Wait for the interface to acquire an IP address of the specified IP address type.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> uint32_t
nm_wait_for_ip(
const char \*pszInterfaceName,
uint32_t timeout,
NET_ADDR_TYPE addrTypes
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszInterfaceName&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>timeout&lt;/code> - maximum time (in seconds) to wait (until the link has an IP address of the specified address type) before timing out of the request; specify 0 for no timeout (wait indefinitely)&lt;/li>
&lt;li>&lt;code>addrTypes&lt;/code> - type of IP address; one of the following values:
&lt;ul>
&lt;li>&lt;code>STATIC_IPV4&lt;/code>&lt;/li>
&lt;li>&lt;code>STATIC_IPV6&lt;/code>&lt;/li>
&lt;li>&lt;code>DHCP_IPV4&lt;/code>&lt;/li>
&lt;li>&lt;code>DHCP_IPV6&lt;/code>&lt;/li>
&lt;li>&lt;code>AUTO_IPV6&lt;/code>&lt;/li>
&lt;li>&lt;code>LINK_LOCAL_IPV6&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_set_network_param">nm_set_network_param&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Set the value of a network parameter for an object.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_set_network_param(
const char \*pszObjectName,
const char \*pszParamName,
const char \*pszParamValue
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszObjectName&lt;/code> - an interface name (for example, &amp;ldquo;eth0&amp;rdquo;) or a file name (for example, /etc/systemd/resolved.conf)&lt;/li>
&lt;li>&lt;code>pszParamName&lt;/code> - name of a parameter associated with the object; specified in the format SectionName_KeyName (for example, Link_MTUBytes represents the MtuBytes key in [Link] section in &lt;a href="https://www.freedesktop.org/software/systemd/man/systemd.network.html">https://www.freedesktop.org/software/systemd/man/systemd.network.html&lt;/a>)&lt;/li>
&lt;li>&lt;code>pszParamValue&lt;/code> - points to the parameter value to set; you can add (+) or remove (-) a parameter by prepending the parameter name with + or -. For example:&lt;/li>
&lt;/ul>
&lt;p>netmgr net_info &amp;ndash;set &amp;ndash;object eth1 &amp;ndash;paramname +Network_Address &amp;ndash;paramvalue &amp;ldquo;10.10.10.1/24&amp;rdquo;&lt;/p>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_get_network_param">nm_get_network_param&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Get the value of a network parameter associated with an object.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> uint32_t
nm_get_network_param(
const char \*pszObjectName,
const char \*pszParamName,
char \*\*ppszParamValue
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Arguments&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>pszObjectName&lt;/code> - an interface name (for example, &amp;ldquo;eth0&amp;rdquo;) or a file name (for example, /etc/systemd/resolved.conf)&lt;/li>
&lt;li>&lt;code>pszParamName&lt;/code> - name of a parameter associated with the object; returned in the format SectionName_KeyName (for example, Link_MTUBytes represents the MtuBytes key in [Link] section in &lt;a href="https://www.freedesktop.org/software/systemd/man/systemd.network.html">https://www.freedesktop.org/software/systemd/man/systemd.network.html&lt;/a>)&lt;/li>
&lt;li>&lt;code>ppszParamValue&lt;/code> - parameter value&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h1 id="service-management-apis">Service Management APIs&lt;/h1>
&lt;h2 id="nm_stop_network_service">nm_stop_network_service&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Stop the network service.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> uint32_t
nm_stop_network_service();
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_restart_network_service">nm_restart_network_service&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Restart the network service.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> uint32_t
nm_restart_network_service();
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;p>nm_stop_dns_service&lt;/p>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Stop the DNS service.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code>uint32_t
nm_stop_dns_service();
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_restart_dns_service">nm_restart_dns_service&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Restart the DNS service.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> uint32_t
nm_restart_dns_service();
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_stop_ntp_service">nm_stop_ntp_service&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Stop the NTP service.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> uint32_t
nm_stop_ntp_service();
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul>
&lt;h2 id="nm_restart_ntp_service">nm_restart_ntp_service&lt;/h2>
&lt;p>&lt;strong>Description&lt;/strong>&lt;/p>
&lt;p>Restart the NTP service.&lt;/p>
&lt;p>&lt;strong>Declaration&lt;/strong>&lt;/p>
&lt;pre>&lt;code> uint32_t
nm_restart_ntp_service();
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: error code&lt;/li>
&lt;/ul></description></item><item><title>Docs: Network Configuration Manager - Python API</title><link>/docs/administration-guide/managing-network-configuration/netmgr.python/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/administration-guide/managing-network-configuration/netmgr.python/</guid><description>
&lt;p>Photon OS 2.0 provides a Python API for the Network Configuration Manager.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#setup-instructions">Setup Instructions&lt;/a>&lt;/li>
&lt;li>&lt;a href="#initialization-steps">Initialization Steps&lt;/a>&lt;/li>
&lt;li>&lt;a href="#get-online-help">Get Online Help&lt;/a>&lt;/li>
&lt;li>&lt;a href="#basic-information">Basic Information&lt;/a>&lt;/li>
&lt;li>&lt;a href="#interface-configuration">Interface Configuration&lt;/a>&lt;/li>
&lt;li>&lt;a href="#ip-address-configuration">IP Address Configuration&lt;/a>&lt;/li>
&lt;li>&lt;a href="#dns-configuration">DNS Configuration&lt;/a>&lt;/li>
&lt;li>&lt;a href="#dhcp-options-duid-and-iaid-configuration">DHCP Options, DUID, and IAID Configuration&lt;/a>&lt;/li>
&lt;li>&lt;a href="#ntp-servers">NTP Servers&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="setup-instructions">Setup Instructions&lt;/h2>
&lt;p>To set up and run the latest version of the Network Manager API for Python:&lt;/p>
&lt;pre>&lt;code># tdnf install pmd pmd-python3
# systemctl start pmd
&lt;/code>&lt;/pre>&lt;h2 id="initialization-steps">Initialization Steps&lt;/h2>
&lt;pre>&lt;code># python3
&amp;gt;&amp;gt;&amp;gt; import pmd
&amp;gt;&amp;gt;&amp;gt; net = pmd.server().net
&lt;/code>&lt;/pre>&lt;h2 id="get-online-help">Get Online Help&lt;/h2>
&lt;p>Get help for all commands.&lt;/p>
&lt;pre>&lt;code>&amp;gt;&amp;gt;&amp;gt; help(net)
&lt;/code>&lt;/pre>&lt;p>Get help for a specific command.&lt;/p>
&lt;pre>&lt;code>&amp;gt;&amp;gt;&amp;gt; help(net.add_ntp_servers)
-in function add_ntp_servers:
add_ntp_servers(...) method of [server.net](http://server.net/) instance
net.add_ntp_servers(ntpservers = [&amp;quot;20.20.20.20&amp;quot;, &amp;quot;25.30.40.70&amp;quot;])
adds ntp servers. returns success: 0, failure: exception.
(END)
&lt;/code>&lt;/pre>&lt;h2 id="basic-information">Basic Information&lt;/h2>
&lt;h3 id="get_system_network_info">get_system_network_info&lt;/h3>
&lt;p>Get network information details that are common to the entire system.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.get_system_network_info()
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>details about the system network (DUID, DNS mode, DNS server list, DNS domain list, NTP server list)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example&lt;/strong>&lt;/p>
&lt;pre>&lt;code>&amp;gt;&amp;gt;&amp;gt; system_network_info = netmgmt.get_system_network_info()
&amp;gt;&amp;gt;&amp;gt; print ( system_network_info)
[{DUID: 00:02:11:22:33:44:55:66:77:20, DNS Mode: (null), DNS ServerList: ['10.10.100.100', '20.20.200.10'], DNS domain list: [' [abcd.com](http://abcd.com)'], NTP ServerList: (null)}]
&lt;/code>&lt;/pre>&lt;h3 id="get_err_info">get_err_info&lt;/h3>
&lt;p>Get information about the specified error number.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.get_err_info(error = &amp;lt;error_number&amp;gt;)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>error - error number&lt;/li>
&lt;/ul>
&lt;p>Here is the list of error numbers:&lt;/p>
&lt;ul>
&lt;li>4097 - invalid parameter&lt;/li>
&lt;li>4098 - not supported&lt;/li>
&lt;li>4099 - out of memory&lt;/li>
&lt;li>4100 - value not found&lt;/li>
&lt;li>4101 - value exists&lt;/li>
&lt;li>4102 - invalid interface&lt;/li>
&lt;li>4103 - invalid mode&lt;/li>
&lt;li>4104 - bad configuration file&lt;/li>
&lt;li>4105 - write failed&lt;/li>
&lt;li>4106 - timout&lt;/li>
&lt;li>4107 - DCHP timeout&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;p>Example&lt;/p>
&lt;pre>&lt;code>&amp;gt;&amp;gt; net.get_err_info(error = 4097)
'invalid parameter'
&lt;/code>&lt;/pre>&lt;h2 id="interface-configuration">Interface Configuration&lt;/h2>
&lt;p>Use these commands to manage the configuration for a network interface.&lt;/p>
&lt;h3 id="get_link_info">get_link_info&lt;/h3>
&lt;p>Get the link info for the specified interface or for all interfaces (if no interface is specified).&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.get_link_info(ifname = interface_name)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name (optional)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: link info&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="get_link_macaddr">get_link_macaddr&lt;/h3>
&lt;p>Get the MAC address for the specified interface or for all interfaces (if no interface is specified).&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.get_link_macaddr(ifname = interface_name)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name (optional)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: MAC address&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="get_link_mode">get_link_mode&lt;/h3>
&lt;p>Get the link mode for the specified interface (auto or manual), or for all interfaces (if no interface is specified).&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.get_link_mode(ifname = interface_name)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name (optional)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: link mode (auto, manual, or unknown)&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="get_link_mtu">get_link_mtu&lt;/h3>
&lt;p>Get the MTU of the specified interface or for all interfaces (if no interface is specified).&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.get_link_mtu(ifname = interface_name)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name (optional)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: link MTU&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="get_link_state">get_link_state&lt;/h3>
&lt;p>Get the link state of the specified interface or for all interfaces (if no interface is specified).&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.get_link_state(ifname = interface_name)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name (optional)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: link state (up, down, unknown)&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="set_link_down">set_link_down&lt;/h3>
&lt;p>Bring down the specified interface.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.set_link_down(ifname = interface_name)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="set_link_macaddr">set_link_macaddr&lt;/h3>
&lt;p>Set the MAC address of the specified interface.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.set_link_macaddr(ifname = interface_name, macaddr = mac_address)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>macaddr&lt;/code> = MAC address&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="set_link_mode">set_link_mode&lt;/h3>
&lt;p>Set the mode (auto or manual) of the specifed interface.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.set_link_mode(ifname = interface_name, link_mode = [auto, manual])
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>link_mode&lt;/code> - auto or manual&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="set_link_mtu">set_link_mtu&lt;/h3>
&lt;p>Set the MTU for the specified interface.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.set_link_mtu(ifname = interface_name, mtu = mtu)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>mtu&lt;/code> - &lt;code>mtu&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="set_link_state">set_link_state&lt;/h3>
&lt;p>Set the state (up or down) of the specified interface.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.set_link_state(ifname = interface_name, link_state = [down, up])
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>link_state&lt;/code> - down or up&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="set_link_up">set_link_up&lt;/h3>
&lt;p>Brings up the specified interface.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.set_link_up(ifname = interface_name)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>link_state&lt;/code> - down or up&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h2 id="ip-address-configuration">IP Address Configuration&lt;/h2>
&lt;p>Use these commands to manage IP address configuration for a network interface.&lt;/p>
&lt;h3 id="add_static_ipv6_addr">add_static_ipv6_addr&lt;/h3>
&lt;p>Add a static IPv6 address to the specified interface.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.add_static_ipv6_addr(ifname = interface_name, addr_prefix = ipv6address_prefix)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>addr_prefix&lt;/code> - IPv6 address prefix&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="del_static_ipv6_addr">del_static_ipv6_addr&lt;/h3>
&lt;p>Delete a static IPv6 address from the specified interface.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.del_static_ipv6_addr(ifname = interface_name, addr_prefix = ipv6address_prefix)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>addr_prefix&lt;/code> - IPv6 address prefix&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="get_ipv4_addr_gateway">get_ipv4_addr_gateway&lt;/h3>
&lt;p>Get the IPv4 address with the prefix and gateway for the specified interface.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.get_ipv4_addr_gateway(ifname = interface_name)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: IPv4 address with the prefix and gateway&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="get_ipv6_addr">get_ipv6_addr&lt;/h3>
&lt;p>Get the list of IPv6 addresses for the specified interface.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.get_ipv6_addr(ifname = interface_name)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: IPv6 address list&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="get_ipv6_addr_mode">get_ipv6_addr_mode&lt;/h3>
&lt;p>Get the address mode for the specified interface to determine whether DHCPv6, autoconf are enabled or disabled.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.get_ipv6_addr_mode(ifname = interface_name)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Status for DHCPv6, autoconf (True=enabled, False=disabled)&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="get_ipv6_gateway">get_ipv6_gateway&lt;/h3>
&lt;p>Get the IPv6 gateway for the specified interface.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.get_ipv6_gateway(ifname = interface_name)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: IPv6 gateway&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="set_ipv4_addr_gateway">set_ipv4_addr_gateway&lt;/h3>
&lt;p>Set the IPv4 address with the prefix and gateway for the specified interface.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.get_ipv4_addr_gateway(ifname = interface_name, addr_mode = [dhcp, static, none], addr_prefix = ipv4addressprefix, gateway = ipv4gateway)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>addr_mode&lt;/code> - address mode - dhcp, static, or none&lt;/li>
&lt;li>&lt;code>addr_prefix&lt;/code> - IPv4 address or prefix&lt;/li>
&lt;li>&lt;code>gateway&lt;/code> - IPv4 gateway&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="set_ipv6_addr_mode">set_ipv6_addr_mode&lt;/h3>
&lt;p>Set the address mode for the specified interface.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.set_ipv6_addr_mode(ifname = interface_name, enable_dhcp = [True, False], enable_autoconf = [True, False])
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>enable_dhcp&lt;/code> - True to enable, False to disable&lt;/li>
&lt;li>&lt;code>enable_autoconf&lt;/code> - True to enable, False to disable&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="set_ipv6_gateway">set_ipv6_gateway&lt;/h3>
&lt;p>Set the IPv6 gateway for the specified interface.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.set_ipv6_gateway(ifname = interface_name, gateway = ipv6gateway)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>gateway&lt;/code> - IPv6 gateway&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h2 id="dns-configuration">DNS Configuration&lt;/h2>
&lt;p>Use these commands to manage DNS domains and servers for a network interface.&lt;/p>
&lt;h3 id="get_dns_domains">get_dns_domains&lt;/h3>
&lt;p>Get the list of DNS domains for the specified interface.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.get_dns_domains(ifname = interface_name)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: list of DNS domains&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="get_dns_servers">get_dns_servers&lt;/h3>
&lt;p>Get the list of DNS servers and the mode for the specified interface.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.get_dns_servers(ifname = interface_name)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: list of DNS servers and mode&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="set_dns_domains">set_dns_domains&lt;/h3>
&lt;p>Set the list of DNS domains for the specified interface.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.set_dns_domains(domains = [&amp;quot;domain1&amp;quot;,&amp;quot;domain2&amp;quot;,...], ifname = interface_name)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>domains&lt;/code> - comma-separated list of one or more domains&lt;/li>
&lt;li>&lt;code>ifname&lt;/code> - interface name&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="set_dns_servers">set_dns_servers&lt;/h3>
&lt;p>Set the list of DNS servers for the specified interface.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.set_dns_servers(dns_mode = [dhcp, static], servers = [&amp;quot;server1&amp;quot;,&amp;quot;server2&amp;quot;, ...], ifname = interface_name)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>dns_mode&lt;/code> - dhcp or static&lt;/li>
&lt;li>&lt;code>servers&lt;/code> - comma-separate list of one or more servers&lt;/li>
&lt;li>&lt;code>ifname&lt;/code> - interface name&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h2 id="dhcp-options-duid-and-iaid-configuration">DHCP Options DUID and IAID Configuration&lt;/h2>
&lt;h3 id="get_link_iaid">get_link_iaid&lt;/h3>
&lt;p>Get the IAID for the specified interface.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.get_link_iaid(ifname = interface)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: IAID&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="set_link_iaid">set_link_iaid&lt;/h3>
&lt;p>Set the IAID for the specified interface.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.set_link_iaid(ifname = interface_name, iaid = &amp;lt;iaid&amp;gt;)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name&lt;/li>
&lt;li>iaid - IAID&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="get_dhcp_duid">get_dhcp_duid&lt;/h3>
&lt;p>Get the DCHP DUID.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.get_dhcp_duid(ifname = interface_name)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name (optional)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: DUID&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="set_dhcp_duid">set_dhcp_duid&lt;/h3>
&lt;p>Set the DCHP DUID.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.set_dhcp_duid(ifname = interface_name duid = duid)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name (optional)&lt;/li>
&lt;li>&lt;code>duid&lt;/code> - DUID to set&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h2 id="ntp-servers">NTP Servers&lt;/h2>
&lt;p>Use these commands to manage the NTP servers list.&lt;/p>
&lt;h3 id="add_ntp_servers">add_ntp_servers&lt;/h3>
&lt;p>Add one or more NTP servers to the NTP servers list.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.add_ntp_servers(ntpservers = [&amp;quot;server1&amp;quot;, &amp;quot;server2&amp;quot;, ...])
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ntpservers&lt;/code> - Comma-separated list of NTP servers to add to the list.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="del_ntp_servers">del_ntp_servers&lt;/h3>
&lt;p>Remove one or more NTP servers from the NTP servers list.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.del_ntp_servers(ntpservers = [&amp;quot;server1&amp;quot;, &amp;quot;server2&amp;quot;, ...])
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ntpservers&lt;/code> - Comma-separated list of NTP servers to remove from the list.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="get_ntp_servers">get_ntp_servers&lt;/h3>
&lt;p>Get the NTP servers list.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.get_ntp_servers()
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: NTP servers list&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="set_ntp_servers">set_ntp_servers&lt;/h3>
&lt;p>Set the NTP servers list.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.set_ntp_servers(ntpservers = [&amp;quot;server1&amp;quot;, &amp;quot;server2&amp;quot;, ...])
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ntpservers&lt;/code> - Comma-separated list of NTP servers to set in the list.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="get_hostname">get_hostname&lt;/h3>
&lt;p>Get the host name.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;p>net.get_hostname()&lt;/p>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: host name&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="set_hostname">set_hostname&lt;/h3>
&lt;p>Set the host name.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.set_hostname(hostname)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>hostname&lt;/code> - name to assign to the host&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="wait_for_ip">wait_for_ip&lt;/h3>
&lt;p>Wait for the specified interface to acquire a valid IP address of the specified IP address type.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.wait_for_ip(ifname = interface_name, timeout = timeout, addrtypes = [ipv4, ipv6, static_ipv4, static_ipv6, dhcp_ipv4, dhcp_ipv6, auto_ipv6, link_local_ipv6])
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>timeout&lt;/code> - maximum time (in seconds) to wait (until the link is up) before timing out of the request; specify 0 for no timeout (wait indefinitely)&lt;/li>
&lt;li>&lt;code>addrtypes&lt;/code> - one of the following address types: ipv4, ipv6, static_ipv4, static_ipv6, dhcp_ipv4, dhcp_ipv6, auto_ipv6, or link_local_ipv6&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0 (when the link has an IP of the specified type)&lt;/li>
&lt;li>failure: exception (for example, timeout expired)&lt;/li>
&lt;/ul>
&lt;h3 id="wait_for_link_up">wait_for_link_up&lt;/h3>
&lt;p>Wait for the specified interface to come up.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.wait_for_link_up(ifname = interface_name, timeout = timeout)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>ifname&lt;/code> - interface name&lt;/li>
&lt;li>&lt;code>timeout&lt;/code> - maximum time (in seconds) to wait (until the link is up) before timing out of the request; specify 0 for no timeout (wait indefinitely)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0 (when link is up)&lt;/li>
&lt;li>failure: exception (for example, timeout expired)&lt;/li>
&lt;/ul>
&lt;h3 id="get_network_param">get_network_param&lt;/h3>
&lt;p>Get the specified network configuration parameter for the specified interface or filename.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.get_network_param(object = IfName or Filename, paramname = SectionName_KeyName)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>object&lt;/code> - an interface name (for example, &amp;quot;eth0&amp;quot;) or a file name (for example, /etc/systemd/resolved.conf)&lt;/li>
&lt;li>&lt;code>paramname&lt;/code> - name of a parameter associated with the object; specified in the format SectionName_KeyName (for example, Link_MTUBytes represents the MtuBytes key in [Link] section in &lt;a href="https://www.freedesktop.org/software/systemd/man/systemd.network.html">https://www.freedesktop.org/software/systemd/man/systemd.network.html&lt;/a>)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul>
&lt;h3 id="set_network_param">set_network_param&lt;/h3>
&lt;p>Set the value of a network configuration parameter for the specified interface or filename.&lt;/p>
&lt;p>&lt;strong>Syntax&lt;/strong>&lt;/p>
&lt;pre>&lt;code>net.set_network_param(object = interface_name or filename, paramname = SectionName_KeyName, paramvalue = key_value)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Parameters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>object&lt;/code> - an interface name (for example, &amp;quot;eth0&amp;quot;) or a file name (for example, /etc/systemd/resolved.conf)&lt;/li>
&lt;li>&lt;code>paramname&lt;/code> - name of a parameter associated with the object; specified in the format SectionName_KeyName (for example, Link_MTUBytes represents the MtuBytes key in [Link] section in &lt;a href="https://www.freedesktop.org/software/systemd/man/systemd.network.html">https://www.freedesktop.org/software/systemd/man/systemd.network.html&lt;/a>)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Returns&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>success: 0&lt;/li>
&lt;li>failure: exception&lt;/li>
&lt;/ul></description></item><item><title>Docs:</title><link>/docs/administration-guide/managing-network-configuration/installing-the-packages-for-tcpdump-and-netcat-with-tdnf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/administration-guide/managing-network-configuration/installing-the-packages-for-tcpdump-and-netcat-with-tdnf/</guid><description>
&lt;p>Photon OS includes the following networking tools:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>tcpdump&lt;/strong>. A networking tool that captures and analyzes packets on a network interface. &lt;code>tcpdump&lt;/code> is not available with the minimal version of Photon OS but available in the repository. The minimal version includes the &lt;code>iproute2&lt;/code> tools by default.&lt;/p>
&lt;p>You can install &lt;code>tcpdump&lt;/code> and its accompanying package &lt;code>libpcap&lt;/code>, a C/C++ library for capturing network traffic, by using &lt;code>tdnf&lt;/code>:&lt;/p>
&lt;pre>&lt;code>&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;p>tdnf install tcpdump&lt;/p>
&lt;pre>&lt;code>
- **netcat**. A tool to send data over network connections with TCP or UDP. This tool is not included in either the minimal or the full version of Photon OS. But since `netcat` furnishes powerful options for analyzing, troubleshooting, and debugging network connections, you might want to install it. To install `netcat', run the following command:
```
tdnf install netcat
&lt;/code>&lt;/pre></description></item></channel></rss>